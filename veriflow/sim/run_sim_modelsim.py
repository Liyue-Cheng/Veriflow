# -----------------------------------------------------------------------------
# file: veriflow/sim/run_sim_modelsim.py
#
# ModelSim/QuestaSim 仿真器的具体实现。
# 定义了 run_modelsim 函数，它会被 SimulationTask 动态加载和调用。
# 流程包括：创建库、编译、生成Tcl脚本、仿真。
#
# v2.0 更新:
# - 添加了宏定义支持，现在可以通过 macro_defines 参数传递宏定义
# v3.0 更新:
# - 使用VeriLogger统一日志接口
# -----------------------------------------------------------------------------

import os
import subprocess

# 从同一包内的 simulators 模块导入工具函数
from .simulators import execute_command, find_rtl_files, format_macro_defines
# 导入统一的verilogger
from ..verilogger import logger as verilogger


def run_modelsim(top_module, rtl_path, tb_path, work_dir, 
                 task_name=None, compile_options=None, sim_options=None, 
                 include_paths=None, tool_paths=None, defines=None,
                 verbosity_level='FULL'):
    """
    使用 ModelSim/QuestaSim 运行仿真。
    这是被 SimulationTask 调用的核心流程函数。
    
    :param top_module: 顶层模块名称
    :param rtl_path: RTL源文件路径
    :param tb_path: 测试平台文件路径
    :param work_dir: 工作目录
    :param task_name: 任务名称（可选）
    :param compile_options: 编译选项列表（可选）
    :param sim_options: 仿真选项列表（可选）
    :param include_paths: 包含路径列表（可选）
    :param tool_paths: 工具路径字典（可选）
    :param defines: 宏定义字典（可选）
    :param verbosity_level: (str) 输出详细级别: 'FULL', 'SIM_ONLY', 'QUIET'
    """
    verilogger.subtitle(f"Preparing ModelSim Simulation for task: {task_name}")

    # 初始化可选参数
    compile_options = compile_options or []
    sim_options = sim_options or []
    include_paths = include_paths or []
    tool_paths = tool_paths or {}
    macro_defines = defines or {}  # 为了内部代码清晰，使用macro_defines变量名

    # 从 tool_paths 获取工具路径，如果不存在，则假设它们在系统PATH中
    vlib_exe = tool_paths.get('vlib', 'vlib')
    vlog_exe = tool_paths.get('vlog', 'vlog')
    vsim_exe = tool_paths.get('vsim', 'vsim')

    # --- 1. 创建工作库 (vlib) ---
    # ModelSim的所有命令都应该在工作目录中执行，以保持输出整洁
    verilogger.subtitle("[ModelSim] Creating 'work' library")
    lib_cmd = f'"{vlib_exe}" work'
    try:
        # 创建库总是使用安静模式，因为它很快且不重要
        execute_command(lib_cmd, work_dir=work_dir, execution_mode='buffered', output_level='QUIET')
        verilogger.debug("Library 'work' created or already exists.")
    except subprocess.CalledProcessError as e:
        # 仅在 vlib 真正失败时记录错误
        if 'already exists' not in str(e.stdout).lower() and 'already exists' not in str(e.stderr).lower():
            verilogger.error(f"Failed to create 'work' library: {e}")
            raise

    # --- 2. 查找并编译文件 (vlog) ---
    verilogger.subtitle("[ModelSim] Starting Compilation")
    rtl_files_list = find_rtl_files(rtl_path)
    all_files_to_compile = rtl_files_list + [os.path.abspath(tb_path)]

    # 构建 vlog 命令
    compile_cmd_parts = [
        f'"{vlog_exe}"',
        '-work work',       # 指定编译到 work 库
        '-sv',              # 启用 SystemVerilog 支持
        '+acc',             # 启用完全可见性，方便调试和波形记录
    ]

    # 添加 include 路径 (ModelSim 使用 +incdir+<path>)
    for path in include_paths:
        compile_cmd_parts.append(f'+incdir+"{os.path.abspath(path)}"')

    # 添加宏定义
    if macro_defines:
        verilogger.info(f"Processing {len(macro_defines)} macro definitions")
        macro_args = format_macro_defines(macro_defines, 'modelsim')
        compile_cmd_parts.extend(macro_args)

    # 添加自定义编译选项
    compile_cmd_parts.extend(compile_options)

    # 添加所有待编译文件
    for file_path in all_files_to_compile:
        compile_cmd_parts.append(f'"{file_path}"')

    compile_cmd = ' '.join(compile_cmd_parts)
    
    # 根据 verbosity_level 决定编译阶段的输出
    compile_output_level = 'FULL' if verbosity_level == 'FULL' else 'QUIET'
    execute_command(
        compile_cmd, 
        work_dir=work_dir,
        execution_mode='buffered',  # 编译总是缓冲模式
        output_level=compile_output_level
    )
    verilogger.success("[ModelSim] Compilation Successful")

    # --- 3. 生成 Tcl 脚本 ---
    verilogger.subtitle("[ModelSim] Generating Tcl script (run.tcl)")
    tcl_script_path = os.path.join(work_dir, 'run.tcl')
    try:
        with open(tcl_script_path, 'w') as f:
            f.write("# ModelSim Tcl script (auto-generated by veriflow framework)\n\n")
            f.write("# Log all signals to waveform\n")
            f.write("add wave -r /*\n\n")
            f.write("# Run simulation until $finish\n")
            f.write("run -all\n\n")
            f.write("# Exit simulator\n")
            f.write("quit -f\n")
        verilogger.info(f"Tcl script created at: {tcl_script_path}")
    except IOError as e:
        verilogger.error(f"Failed to create Tcl script: {e}")
        raise

    # --- 4. 运行仿真 (vsim) ---
    verilogger.subtitle("[ModelSim] Starting Simulation")
    
    # 构建 vsim 命令
    simulate_cmd_parts = [
        f'"{vsim_exe}"',
        '-c',               # 以命令行模式运行，无GUI
        '-do run.tcl',      # 指定启动后要执行的Tcl脚本
    ]
    
    # 添加自定义仿真选项
    simulate_cmd_parts.extend(sim_options)
    
    # 添加要仿真的顶层模块 (格式为 work.<top_module>)
    simulate_cmd_parts.append(f"work.{top_module}")

    simulate_cmd = ' '.join(simulate_cmd_parts)

    # 根据 verbosity_level 决定仿真阶段的模式和输出
    if verbosity_level in ['FULL', 'SIM_ONLY']:
        sim_execution_mode = 'streaming'
    else: # QUIET
        sim_execution_mode = 'buffered'

    sim_output_level = 'QUIET' if verbosity_level == 'QUIET' else 'FULL'

    # 在 work_dir 中执行仿真
    execute_command(
        simulate_cmd, 
        work_dir=work_dir,
        execution_mode=sim_execution_mode,
        output_level=sim_output_level
    )
    verilogger.success("[ModelSim] Simulation Successful")

    # 检查波形文件是否存在
    wave_file_path = os.path.join(work_dir, "waveform.wlf")
    if os.path.exists(wave_file_path):
        verilogger.info(f"Waveform file generated: {wave_file_path}")
    else:
        verilogger.warning("Waveform file 'waveform.wlf' not found. Check your Tcl script or simulation settings.")
