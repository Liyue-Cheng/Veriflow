# VeriFlow (THIS README GENERATED BY AI)

[![MIT License](https://img.shields.io/badge/License-MIT-green.svg)](https://choosealicense.com/licenses/mit/)
[![Python 3.8+](https://img.shields.io/badge/python-3.8+-blue.svg)](https://www.python.org/downloads/)
[![Development Status](https://img.shields.io/badge/status-alpha-red.svg)]()

A comprehensive Python-based digital circuit verification and simulation framework designed for hardware engineers and verification specialists.

## Overview

VeriFlow provides a unified, Python-native environment for digital circuit simulation, verification, and analysis. It bridges the gap between hardware description languages and modern software development practices, offering type-safe bit vector operations, multi-simulator support, and advanced signal processing metrics.

## Key Features

### 🔧 Multi-Simulator Support
- **Icarus Verilog** - Open-source Verilog simulator
- **ModelSim/QuestaSim** - Industry-standard simulation
- **Synopsys VCS** - High-performance commercial simulator  
- **Xilinx Vivado** - FPGA-focused simulation environment

### 🎯 Strongly-Typed Bit Vectors
- **VerilogBits** class with hardware-accurate behavior
- Verilog-style `[MSB:LSB]` indexing and slicing
- Type-safe operations preventing common verification errors
- Seamless integration with Python's numeric ecosystem

### 📊 Advanced Signal Processing Metrics
- **MRED** (Maximum Relative Error Distance)
- **NMED** (Normalized Mean Error Distance) 
- **SNR** (Signal-to-Noise Ratio)
- **PSNR** (Peak Signal-to-Noise Ratio)
- Enhanced data matching with mismatch analysis

### 🗂️ Memory File Processing
- Support for Verilog `$readmemh` and `$readmemb` formats
- Type-safe memory file I/O operations
- Integration with VerilogBits for consistent data handling

### 🚀 Automated Task Management
- **SimulationTask** runner with pre/post-simulation hooks
- Unified logging system with multiple output formats
- Cross-platform path management and project organization
- Comprehensive error handling and reporting

## Installation

### Prerequisites
- Python 3.8 or higher
- NumPy >= 1.20.0
- bitstring >= 3.1.0

### Install from Source
```bash
git clone https://github.com/Liyue-Cheng/Veriflow.git
cd Veriflow
pip install -e .
```

### Install Dependencies
```bash
pip install numpy>=1.20.0 bitstring>=3.1.0
```

## Quick Start

### Basic Simulation Example

```python
import os
from veriflow import SimulationTask, logger
from veriflow.path_tools import find_project_root

# Create simulation task
task = SimulationTask()
task.task_name = "CounterTest"

# Configure Icarus Verilog simulation
task.sim_config = {
    'simulator': 'iverilog',
    'top_module': 'counter_tb',
    'rtl_path': './rtl',
    'tb_path': './tb/counter_tb.v',
    'work_dir': './sim_outputs',
    'compile_options': ['-g2012']
}

# Run simulation
success = task.run()
if success:
    logger.info("Simulation completed successfully!")
```

### Working with VerilogBits

```python
from veriflow import VerilogBits

# Create bit vectors
a = VerilogBits('8b10101010')  # 8-bit binary
b = VerilogBits(0xFF, 8)       # 8-bit from integer
c = VerilogBits('hA5')         # Hex format

# Verilog-style operations
result = a & b                 # Bitwise AND
msb = a[7]                     # Get MSB
slice_val = a[7:4]             # Get bits [7:4]

# Convert to different formats
print(f"Binary: {a.bin}")     # Binary string
print(f"Hex: {a.hex}")        # Hex string  
print(f"Int: {a.int}")        # Integer value
```

### Signal Processing Metrics

```python
import numpy as np
from veriflow import MetricsCalculator, calculate_snr

# Create test data
reference = np.array([1.0, 2.0, 3.0, 4.0])
test_data = np.array([1.1, 1.9, 3.1, 3.9])

# Calculate metrics
calc = MetricsCalculator()
mred = calc.calculate_mred(reference, test_data)
snr = calculate_snr(reference, test_data)

print(f"MRED: {mred:.6f}")
print(f"SNR: {snr:.2f} dB")
```

### Memory File Processing

```python
from veriflow import MemTools, VerilogBits

# Read hex memory file
mem_tools = MemTools()
data = mem_tools.read_mem_file('memory.hex', word_width=32, is_hex=True)

# Each element is a VerilogBits object
for i, word in enumerate(data):
    print(f"Address {i:04x}: {word.hex}")

# Write memory file
output_data = [VerilogBits(i * 2, 32) for i in range(256)]
mem_tools.write_mem_file('output.hex', output_data, is_hex=True)
```

## Project Structure

```
VeriFlow/
├── veriflow/                   # Core framework
│   ├── sim/                    # Simulator interfaces
│   │   ├── run_sim_iverilog.py # Icarus Verilog support
│   │   ├── run_sim_modelsim.py # ModelSim support
│   │   ├── run_sim_vcs.py      # VCS support
│   │   └── run_sim_vivado.py   # Vivado support
│   ├── task_runner.py          # Simulation task management
│   ├── verilog_bits.py         # Strongly-typed bit vectors
│   ├── metrics.py              # Signal processing metrics
│   ├── mem_tools.py            # Memory file utilities
│   ├── path_tools.py           # Cross-platform path handling
│   └── verilogger.py           # Unified logging system
├── framework/                  # Demo projects and utilities
│   ├── demo-projects/          # Example projects
│   └── utils/                  # Bundled EDA tools
└── tests/                      # Comprehensive test suite
```

## Demo Projects

The framework includes complete demo projects showcasing different features:

### Counter Example
```bash
cd framework/demo-projects/counter
python scripts/run_counter_test.py
```

This demonstrates:
- Multi-simulator support (Icarus Verilog, ModelSim)
- Automated waveform generation
- Comprehensive logging and reporting

### Minimal Example
```bash
cd framework/demo-projects/minimal  
python scripts/simulation.py
```

A streamlined example perfect for getting started with VeriFlow.

## Advanced Features

### Custom Pre/Post Simulation Hooks

```python
def my_pre_sim(task):
    """Custom setup before simulation"""
    logger.info("Setting up test environment...")
    # Custom initialization code

def my_post_sim(task):
    """Custom analysis after simulation"""
    # Parse results, generate reports
    task.passed = check_simulation_results()

task.pre_sim_handler = my_pre_sim
task.post_sim_handler = my_post_sim
```

### Macro Definitions Support

```python
task.sim_config = {
    'simulator': 'iverilog',
    'defines': {
        'DEBUG_MODE': None,        # Simple define
        'CLK_FREQ': '100000000',   # Define with value
        'DATA_WIDTH': '32'
    }
}
```

### Cross-Platform Tool Paths

```python
# Windows
tool_paths = {
    'iverilog': r'C:\iverilog\bin\iverilog.exe',
    'vvp': r'C:\iverilog\bin\vvp.exe'
}

# Linux/Mac  
tool_paths = {
    'iverilog': '/usr/bin/iverilog',
    'vvp': '/usr/bin/vvp'
}

task.sim_config['tool_paths'] = tool_paths
```

## Testing

VeriFlow includes a comprehensive test suite:

```bash
# Run all tests
python -m pytest veriflow/internal_test/

# Run specific test categories
python -m pytest veriflow/internal_test/test_verilog_bits.py
python -m pytest veriflow/internal_test/test_metrics.py
python -m pytest veriflow/internal_test/test_mem_tools.py
```

## Contributing

We welcome contributions! Please see our contributing guidelines:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

### Development Setup

```bash
git clone https://github.com/Liyue-Cheng/Veriflow.git
cd Veriflow
pip install -e ".[dev]"
pre-commit install
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built on the excellent [bitstring](https://github.com/scott-griffiths/bitstring) library
- Inspired by industry-standard EDA workflows
- Designed for the hardware verification community

## Support

- 📧 Email: liyue_cheng@163.com
- 🐛 Issues: [GitHub Issues](https://github.com/Liyue-Cheng/Veriflow/issues)
- 📖 Documentation: Coming soon

## Roadmap

- [ ] SystemVerilog support
- [ ] UVM integration
- [ ] Waveform analysis tools
- [ ] Cloud simulation support
- [ ] GUI interface
- [ ] Formal verification integration

---

**VeriFlow** - Bridging Hardware and Software Verification 🚀
